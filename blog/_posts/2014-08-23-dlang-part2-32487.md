---
layout: blogpost
title: "Some Comments on 'D for the Win'"
draft: true
description: "Lions, and tigers, and bears! Oh, my"
imageurl: http://tomerfiliba.com/static/res/2014-08-22-ohno.jpg
imagetitle: "Doh!"
---

So it turns out my last post, [D for the Win](http://tomerfiliba.com/blog/dlang/) got all over
the place. I published it late at night, went to bed, and when I got back in the morning all hell 
broke loose. And even more surprisingly, the reactions (at the ones I've seen on 
[reddit](http://www.reddit.com/r/programming/comments/2e49tm/d_for_the_win/) and 
[hacker news](https://news.ycombinator.com/item?id=8211639)) were on-topic. I hope it means 
I got my message through. 

Since I'm not able to reply to each comment, I'll try to provide answers to some repeating 
questions and concerns people had. 

1. No, "Dlang Dlang uber Alles" was not meant to be offensive or avert discussion by means of 
[pulling a Godwin](http://en.wikipedia.org/wiki/Godwin's_law). Yes, I am aware of the context.
I'm Jewish. I just thought it's funny and liked the sound of it. My sincere apologies to anyone who
got offended by this.

2. Sorry, I've never heard of [Nimrod](http://nimrod-lang.org/) until now. If I had, I'd surely 
try it out. But the product I'm working on is already committed to D at this point, and from what
I gather Nimrod is still more quite unstable. 

3. Some people said that *system programming* is anything that's run natively (i.e., not in a VM).
That's not the [definition I'm using](http://en.wikipedia.org/wiki/System_programming_language). 
System programming involves talking to hardware, drivers, plugging some inline-assembly here 
and there, etc., in order to create a predictable

4. The C10K problem moved people from thread-per-IO to asynchronous IO (`epoll`, `kqueue`, `IOCP`, etc)
in few threads. The C10M problem moves IO from the kernel into userland ("the kernel is the problem, 
not the solution"). You simply can't process enough data when you have several system calls per IO. 

Context switches are expansive, the kernel requires accounting on its own, and you don't get to utilize 
hardware offloading when you go through the standard kernel stacks. For instance, I got a 
**factor 12 improvement** just by moving my code to userland polling instead of relying on `epoll`.
In both cases my program consumed 100% CPU, but kernel time plummeted from 40% to 1%.

5. C++
6. Go
7. GC and memory management
8. D and Adoption, no large project in D













