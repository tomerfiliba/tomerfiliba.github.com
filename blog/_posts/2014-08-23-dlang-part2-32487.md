---
layout: blogpost
title: "Some Notes on 'D for the Win'"
draft: true
description: "Lions, and tigers, and bears! Oh, my"
imageurl: http://tomerfiliba.com/static/res/2014-08-22-ohno.jpg
imagetitle: "Doh!"
---

So it turns out my last post, [D for the Win](http://tomerfiliba.com/blog/dlang/) got all over
the place. I published it late at night, went to bed, and when I got back in the morning all hell 
broke loose. And even more surprisingly, the vast majority of the reactions (at the ones I've seen on 
[reddit](http://www.reddit.com/r/programming/comments/2e49tm/d_for_the_win/) and 
[hacker news](https://news.ycombinator.com/item?id=8211639)) were on-topic. I hope it means 
I got my message through. 

Since I'm not able to reply to everything, I'll try to provide answers to some repeating 
questions and concerns people had. 

1.  No, "Dlang Dlang uber Alles" was not meant to be offensive or avert discussion by means of 
    [pulling a Godwin](http://en.wikipedia.org/wiki/Godwin's_law). Yes, I am aware of the context.
    I'm Jewish. I just thought it's funny and liked the sound of it. My sincere apologies to anyone who
    got offended by this.

2.  Sorry, I've never heard of [Nimrod](http://nimrod-lang.org/) until now. If I had, I'd surely 
    try it out. But the product I'm working on is already committed to D at this point, and from what
    I gather Nimrod is still quite unstable. 

3.  Some people said that *system programming* is anything that's run natively (i.e., compiles to machine code).
    [Well no](http://en.wikipedia.org/wiki/System_programming_language). I'm not sure if there's a definite 
    definition, but system programming involves interfacing with hardware, drivers, and various other components.
    It usually also requires fine-grained control over resources (CPU, memory, affinity, etc.), 
    and generally such systems are expected to deliver steady performance (soft-realtime behavior).
    
    Therefore, I'd characterize a system-programming language as one that provides:
    * Native pointers, unsafe casts - hardware devices don't chew on your fancy object model. 
      I mean, they gladly will, but I don't suppose you'll be as glad.
    * C ABI - interfacing with system libraries and even the kernel directly. Some system calls
      are not exported through libraries, so being able to call a `cdecl` [variadic function](http://man7.org/linux/man-pages/man2/syscall.2.html)
      is extremely useful.
    * Manual memory management - GC is a great thing in general, but when your system can't pause
      for indefinite times at random you have to think twice. Also, when you have to control overall 
      memory consumption, preallocating memory is the way to go.
    * Generate efficient machine code, and perhaps even support inline-assembly - at the bottlenecks,
      every CPU cycle counts.

4.  The C10K problem moved people from thread-per-IO to asynchronous IO (`epoll`, `kqueue`, `IOCP`, etc)
    in few threads. The C10M problem moves IO from the kernel into userland ("the kernel is the problem, 
    not the solution"). You simply can't process enough data when you have several system calls per IO. 

    Context switches are expansive, the kernel requires accounting on its own, and you don't get to utilize 
    hardware offloading when you go through the standard kernel stacks. For instance, I got a 
    **factor 12 improvement** just by moving my code to userland polling instead of relying on `epoll`.
    In both cases my program consumed 100% CPU, but kernel time plummeted from 40% to 1%.

5. C++
6. Go
7. GC and memory management
8. D and Adoption, no large project in D







