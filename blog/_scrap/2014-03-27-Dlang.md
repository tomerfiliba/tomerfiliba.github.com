---
layout: blogpost
draft: true
title: "D for the Win"
description: "New adventures with a new language"
imageurl: http://tomerfiliba.com/static/res/2014-03-27-dlogo.png
imagetitle: D Programming Language
---

I first heard of the [D Programming Language](http://dlang.org/) around 2002. Back in the day, I was eagerly
trying to invent new languages with idiotic syntaxes and all sorts of crazy ideas. I was young and passionate and 
totally inexperienced. But those were fun times. I recalled this when I read the introduction to 
[Alexandrescu's](http://en.wikipedia.org/wiki/Andrei_Alexandrescu) book, *The D Programming Language*:

> Walter Bright, a C and C++ compiler writer, [...] set out to define a language as he thought "it should be done."
> Many of us dream at some point dream at some point of defining the Right Language [...]

So I had this *warm and fuzzy feeling* &trade; to start with. Three weeks and 5000 LoC later, I decided to write 
down my experience so far with the language. Clearly such a short while isn't enough to draw meaningful 
conclusions from, but I wish to share what little experience I already have because I think it has value 
on its own.

Choosing a [system programming language](http://en.wikipedia.org/wiki/System_programming_language) for a large,
resource-constrained project is tough. On the one hand there's C - rock solid, low-level, and any respectable 
open-source project comes with C bindings. But then again, it's 2014 and C's a dinosaur. Isn't it time
for more advance control flows like exceptions, more type-safety, closures, a richer type system, stronger 
preprocessing capabilities and (perhaps) even garbage collection? 

The next obvious choice is C++, and if you remember my [last post](http://tomerfiliba.com/blog/ConstructPlusPlus/),
it didn't go under my radar. But it's long since C++ was a *language*. It is now a 
[conglomerate](http://www.stroustrup.com/C++11FAQ.html) of plagiarism, incomprehensible syntax and 
impossibly-complicated semantics. Trying to retain compatibility with C at all costs has got them shooting for the 
stars with wood arrows. And on the more practical side, compilation times of C++ code are a non realistic, 
and it takes years for [mainline compilers](http:///) to catch up with the standards.

I spent about a week looking for better languages and tools. The contestants were [Go](http://golang.org/), 
[Rust](http://www.rust-lang.org/) and D. Rust has a host of good ideas but it's clearly unstable and it would be 
years before it achieved maturity. It felt too experimental for us to seriously consider it, so it went out of question.
Go is just as new and immature as Rust, but it has a much stronger sponsor and a large community. That, 
and unlike Rust, Go still remains in the familiar playground of C-style imperative languages. 

On the other hand, Go suffers from horrible syntax, has nor pointer arithmetics neither guarantees about memory-layout,
so working with hardware, drivers, or interfacing with C is hard. It basically feels like a good server-side 
programming language, which is exactly what it was conceived for, but system programming requires more fine-grained 
control over resources. Go lost the race too.
  





